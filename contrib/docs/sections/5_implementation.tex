\clearpage
\SectionWithSubsection{Реализация веб-приложения}
\SubsectionWithParagraph{Обоснование выбора программной платформы}

Для реализации веб-приложения был выбран язык программирования Python [2] и фреймворк FastAPI [3]. FastAPI представляет собой веб-фреймворк для создания API на языке Python. Он позволяет обрабатывать запросы асинхронно и поддерживает протокол WebSocket. Для сериализации, десериализации и валидации запросов использовалесь библиотека Pydantic [4].

Для долговременного хранения данных веб-приложения была выбрана распространённая СУБД PostgreSQL [5], обладающая следующими преимуществами: бесплатность, расширяемость, большое сообщество, широкая поддержка среди инструментов разработки программного обеспечения.

Для создания моделей, соответствующих таблицам в реляционной базе данных, была выбрана библиотека SQLAlchemy [6]. Она предоставляет уровень абстракции над объектами базы данных, позволяя работать с ними как с объектами Python, а также предоставляет возможность создавать сложные запросы при помощи функций Python.

Для управления миграциями был выбран инструмент Alembic [7]. Данный инструмент позволяет отслеживать изменения в структуре базы данных, а также предоставляет возможность автоматической генерации миграций на основе изменений в моделях. Также Alembic предоставляет возможность отката к более ранней версии базы данных.

Для перевода текста используется сервис g4f [8]. Он выступает как посредник между веб-приложением и публичными API различных провайдеров, обеспечивая работу веб-приложения и упрощая его настройку. Сервис translation-consumer считывает задачи на перевод из очереди RabbitMQ, отправляет запросы по указанному в переменных окружения адресу с необходимой полезной нагрузкой (текст, который нужно перевести, текст стиля перевода, название модели, название провайдера) и на основе полученных ответов создаёт объекты переведённых статей. 

Для отправки электронной почты был выбран сервис Unisender [9], который предоставляет API для создания рассылок и отправки одиночных писем.

\SubsectionBetweenParagraphs{Реализация серверной части веб-приложения}

В соответствии с диаграммой вариантов использования функции, доступные пользователям, были реализованы в исходном коде. Исходный код веб-приложения представлен в Приложении А.

\SubsectionBetweenParagraphs{Изменение учётной записи}

Функция "изменение учётной записи" (1) в исходном коде реализована функциями change\_name, request\_password\_restoration\_code и restore\_password.

Функция change\_name находится в модуле src.routers.users.views.py. Она принимает HTTP PATCH запрос по пути "/users/{user\_id}/name/" и изменяет имя пользователя на новое, полученное из тела запроса.

% \begin{sloppypar}
    Функция request\_password\_restoration\_code находится в модуле src.routers.auth.views.py. Она принимает HTTP POST запрос по пути "/auth/restore-password/request/" c адресом электронной почты пользователя в параметрах строки запроса, создаёт код подтверждения смены пароля в базе данных и отправляет письмо по адресу электронной почты со ссылкой на страницу смены пароля.
% \end{sloppypar}

Функция restore\_password находится в модуле src.routers.auth.views.py. Она принимает HTTP POST запрос по пути "/auth/restore-password/confirm/" с кодом подтверждения и новым паролем, проверяет существование полученного кода и изменяет хранимый в базе данных хэш пароля пользователя на хэш полученного нового пароля.

\SubsectionBetweenParagraphs{Просмотр открытых сессий}

Функция "просмотр открытых сессий" (2) в исходном коде реализована функцией get\_sessions. Данная функция находится в модуле src.routers.sessions.views.py. Она принимает HTTP GET запрос по пути "/sessions/" и возвращает список всех открытых сессий текущего пользователя из базы данных (сессий, у которых значение в столбце closed\_at равняется NULL).

\SubsectionBetweenParagraphs{Завершение открытых сессий}

Функция "завершение открытых сессий" (3) в исходном коде реализована функцией close\_sessions. Данная функция находится в модуле src.routers.sessions.views.py. Она принимает HTTP POST запрос по пути "/sessions/close/" и закрывает все открытые сессии текущего пользователя (устанавливает в столбец closed\_at текущее время сервера).

\SubsectionBetweenParagraphs{Изменение списка исходных статей}

Функция "изменение списка исходных статей" (4) в исходном коде реализована функциями upload\_article, update\_article, delete\_article. Данные функции находятся в модуле src.routers.articles.views.py.

Функция upload\_article находится в модуле src.routers.users.views.py. Она принимает HTTP POST запрос по пути "/articles/" и добавляет в базу данных строку с информацией об исходной статье, десериализованной из тела запроса. Значение столбца user\_id берётся из маркера доступа пользователя, передаваемого через Cookie.

Функция update\_article находится в модуле src.routers.users.views.py. Она принимает HTTP PUT запрос по пути "/articles/{article\_id}/", проверяет принадлежность исходной статьи текущему пользователю по идентификатору статьи, полученному из пути запроса, и обновляет запись о статье согласно данным, десериализованным из тела запроса.

Функция delete\_article находится в модуле src.routers.users.views.py. Она принимает HTTP DELETE запрос по пути "/articles/{article\_id}/", проверяет принадлежность исходной статьи текущему пользователю по идентификатору статьи, полученному из пути запроса, и удаляет исходную или переведённую статью по идентификатору.

\SubsectionBetweenParagraphs{Изменение списка переведённых статей}

Функция "изменение списка переведённых статей" (5) в исходном коде реализована функциями delete\_article, рассмотренной выше, и create\_translation.

Функция create\_translation находится в модуле src.routers.translation.views.py. Она принимает HTTP POST запрос по пути "/translation/" и отправляет в RabbitMQ сообщение подписчику-переводчику о запуске перевода. Тело запроса должно содержать идентификатор статьи, массив идентификаторов конечных языков, на которые требуется выполнить перевод, а также идентификаторы стиля и модели перевода.

\SubsectionBetweenParagraphs{Изменение списка жалоб на переводы своих статей}

Функция "изменение списка жалоб на переводы своих статей" (6) в исходном коде реализована функциями create\_report, update\_report, update\_report\_status.

Функция create\_report находится в модуле src.routers.reports.views.py. Она принимает HTTP POST запрос по пути "/articles/{article\_id}/report/", проверяет принадлежность переведённой статьи текущему пользователю по идентификатору статьи, полученному из пути запроса, и добавляет в базу данных строку с информацией о жалобе (текст и идентификатор причины жалобы из тела запроса).

Функция create\_report находится в модуле src.routers.reports.views.py. Она принимает HTTP PUT запрос по пути "/articles/{article\_id}/report/", проверяет принадлежность переведённой статьи текущему пользователю и обновляет информацию о жалобе (текст и причина жалобы в теле запроса).

Функция create\_report находится в модуле src.routers.reports.views.py. Она принимает HTTP PATCH запрос по пути "/articles/{article\_id}/report/status/", проверяет, имеет ли пользователь право устанавливать жалобе новый статус, и обновляет статус жалобы по идентификатору статьи.

\SubsectionBetweenParagraphs{Просмотр своих уведомлений}

Функция "просмотр своих уведомлений" (7) в исходном коде реализована функцией get\_notifications\_list. Данная функция находится в модуле src.routers.notifications.views.py. Она принимает HTTP GET запрос по пути "/notifications/" и возвращает список непрочитанных (имеющих в столбце read\_at значение NULL) уведомлений пользователя из базы данных.

\SubsectionBetweenParagraphs{Изменение списка комментариев к жалобам на переводы своих статей}

Функция "изменение списка комментариев к жалобам на переводы своих статей" (8) включает в себя ровно две функции: "получение списка комментариев к жалобе" (9) и "создание комментария" (10).

Функция "получение списка комментариев к жалобе" (9) в исходном коде реализована функцией get\_comments. Данная функция находится в модуле src.routers.reports.views.py. Она принимает HTTP GET запрос по пути "/articles/{article\_id}/report/comments/", проверяет, имеет ли право текущий пользователь получать список комментариев к этой жалобе по идентификатору статьи, полученному из пути запроса, и возвращает список комментариев к жалобе из базы данных.

Функция "создание комментария" (10) в исходном коде реализована функцией create\_comment. Данная функция находится в модуле src.routers.reports.views.py. Она принимает HTTP POST запрос по пути "/articles/{article\_id}/report/comments/" создаёт комментарий к жалобе по идентификатору статьи, к которой была оставлена жалоба.

\SubsectionBetweenParagraphs{Изменение списка настроек переводчика}

Функция "изменение списка настроек переводчика" (11) в исходном коде реализована функциями create\_config, update\_config и delete\_config.

Функция create\_config находится в модуле src.routers.config.views.py. Она принимает HTTP POST запрос по пути "/configs/", проверяет, занято ли название конфигурации переводчика для данного пользователя, и создаёт новую строку в базе данных с полученным названием, идентификатором модели перевода и стиля перевода, а также массивом идентификаторов конечных языков.

Функция create\_config находится в модуле src.routers.config.views.py. Она принимает HTTP PUT запрос по пути "/configs/{config\_id}/", проверяет принадлежность конфигурации текущему пользователю и занято ли новое название конфигурации переводчика для данного пользователя, и обновляет строку в базе данных согласно десериализованным из тела запроса данным.

Функция create\_config находится в модуле src.routers.config.views.py. Она принимает HTTP DELETE запрос по пути "/configs/{config\_id}/", проверяет принадлежность конфигурации текущему пользователю и удаляет конфигурацию по её идентификатору.

\SubsectionBetweenParagraphs{Регистрация}

Функция "регистрация" (12) в исходном коде реализована функцией register. Данная функция находится в модуле src.routers.auth.views.py. Она принимает HTTP POST запрос по пути "/auth/register/", проверяет, занят ли адрес электронной почты, и создаёт нового пользователя по имени, адресу электронной почты и паролю, полученным из тела запроса. Значение столбца email\_verified устанавливается в false, и пользователь должен дополнительно подтвердить свой адрес электронной почты.

\SubsectionBetweenParagraphs{Аутентификация}

Функция "аутентификация" (13) в исходном коде реализована функцией login. Данная функция находится в модуле src.routers.auth.views.py. Она принимает HTTP POST запрос по пути "/auth/login/", проверяет существование пользователя с полученными из тела запроса адресом электронной почты и паролем и аутентифицирует пользователя: закрывает открытые сессии по IP-адресу и user\_agent, полученными из заголовков запроса, создаёт новую сессию пользователя и возвращает пару маркеров для доступа к ресурсам и обновления маркеров.

\SubsectionBetweenParagraphs{Изменение списка открытых жалоб}

Функция "изменение списка открытых жалоб" (14) в исходном коде реализована функцией update\_report\_status. Данная функция находится в модуле src.routers.reports.views.py и была рассмотрена выше.

\SubsectionBetweenParagraphs{Создание комментариев для жалоб}

Функция "создание комментариев для жалоб" (15) в исходном коде реализована функцией create\_comment. Данная функция находится в модуле src.routers.reports.views.py и была рассмотрена выше.

\SubsectionBetweenParagraphs{Просмотр статистики жалоб}

Функция "просмотр статистики жалоб" (16) в исходном коде реализована функциями get\_models\_stats и get\_prompts\_stats.

Функция get\_models\_stats находится в модуле src.routers.analytics.views.py. Она принимает HTTP GET запрос по пути "/analytics/models-stats/" и возвращает статистику жалоб по всем моделям перевода в базе данных: сколько было подано жалоб на переводы по каждой модели и какие статусы у этих жалоб на данный момент.

Функция get\_prompts\_stats находится в модуле src.routers.analytics.views.py. Она принимает HTTP GET запрос по пути "/analytics/prompts-stats/" и аналогична функции get\_models\_stats, но возвращает статистику по стилям перевода, а не моделям перевода.

\SubsectionBetweenParagraphs{Изменение списка стилей перевода}

Функция "изменение списка стилей перевода" (17) в исходном коде реализована функциями create\_prompt, update\_prompt и delete\_prompt.

Функция create\_prompt находится в модуле src.routers.prompts.views.py. Она принимает HTTP POST запрос по пути "/prompts/", проверяет, занято ли название стиля перевода существующей строкой в базе данных, и добавляет новый стиль перевода в базу данных по названию и тексту, полученным из тела запроса.

Функция update\_prompt находится в модуле src.routers.prompts.views.py. Она принимает HTTP PUT запрос по пути "/prompts/{prompt\_id}/", проверяет, занято ли новое название стиля перевода, и обновляет строку в базе данных по идентификатору стиля перевода, полученному из пути запроса, согласно данным из тела запроса.

Функция delete\_prompt находится в модуле src.routers.prompts.views.py. Она принимает HTTP DELETE запрос по пути "/prompts/{prompt\_id}/", проверяет существование стиля перевода по идентификатору из пути запроса и удаляет стиль по идентификатору.

\SubsectionBetweenParagraphs{Изменение списка моделей перевода}

Функция "изменение списка моделей перевода" (18) в исходном коде реализована функциями create\_model, update\_model и delete\_model.

Функция create\_model находится в модуле src.routers.models.views.py. Она принимает HTTP POST запрос по пути "/models/", проверяет, занято ли название модели перевода, и добавляет в базу данных строку с отображаемым названием, внутренним названием и провайдером, полученным из тела запроса.

Функция update\_model находится в модуле src.routers.models.views.py. Она принимает HTTP PUT запрос по пути "/models/{model\_id}/", проверяет, занято ли новое название модели перевода, и обновляет строку в базе данных по идентификатору модели, полученному из пути запроса, согласно данным, полученным из тела запроса.

Функция delete\_model находится в модуле src.routers.models.views.py. Она принимает HTTP DELETE запрос по пути "/models/{model\_id}/" и удаляет модель перевода из базы данных по её идентификатору, полученному из тела запроса.

\SubsectionBetweenParagraphs{Изменение списка пользователей}

Функция "изменение списка пользователей" (19) в исходном коде реализована функциями create\_user, update\_user и delete\_user.

Функция create\_user находится в модуле src.routers.users.views.py. Она принимает HTTP POST запрос по пути "/users/" и создаёт пользователя с заданным именем, адресом электронной почты, паролем и ролью. Эти данные десериализуются из тела запроса.

Функция update\_user находится в модуле src.routers.users.views.py. Она принимает HTTP PUT запрос по пути "/users/{user\_id}/" и обновляет строку в базы данных по идентификатору пользователя, полученному из пути запроса, согласно данным, полученным из тела запроса.

Функция delete\_user находится в модуле src.routers.users.views.py. Она принимает HTTP DELETE запрос по пути "/users/{user\_id}/" и удаляет пользователя по идентификатору, полученному из пути запроса.

Функции "создание пользователей" (20), "создание модераторов" (21) и "создание администраторов" (22) в исходном коде реализованы функцией src.routers.users.views.create\_user, рассмотренной выше.

Для передачи данных от клиента серверу и обратно используется протокол HTTP и формат JSON. FastAPI автоматически проверяет тело запроса согласно указанной схеме, созданной при помощи Pydantic, что повысило читаемость кода.

\SubsectionBetweenParagraphs{Реализация базы данных}

Согласно логической схеме базы данных, были созданы объекты базы данных. Модели SQLAlchemy объявлены в модуле src.database.models.py, представленном в Приложении А. Для изменения состояния базы данных использовался инструмент Alembic. Скрипт для создания базы данных и её объектов представлен в Приложении Б.

Для работы с базой данных в SQLAlchemy необходимо создать объект сессии. Предварительная настройка подключения представлена в листинге \ref{listing:db_connection}.

\begin{lstlisting}[caption={Настройка подключения к базе данных}, label={listing:db_connection}]
from sqlalchemy.ext.asyncio import \
    async_sessionmaker, \
    create_async_engine
    
engine = create_async_engine(Database.url)
Session = async_sessionmaker(engine)
\end{lstlisting}

Затем необходимо создать экземпляр класса Session и работать с данным экземпляром. Класс Session предоставляет методы для добавления строк в базу данных (add), фиксации изменений в транзакции (commit), отката транзакции (rollback), закрытия сессии (close) и так далее. При помощи экземпляра данного класса можно выполнять операции с базой данных.

\SubsectionBetweenParagraphs{Реализация клиентской части веб-приложения}

Для реализации клиентской части веб-приложения использовался фреймворк Vue [10] и библиотека компонентов Vuetify [11]. Фреймворк предоставляет широкие возможности по настройке приложения и повторному использованию кода, а библиотека предоставляет богатый выбор компонентов, которые можно использовать без тщательной настройки в виде, в котором они поставляются.

Для обеспечения навигации по сайту, выполненному по технологии одностраничного приложения, использовался встроенный инструмент VueRouter, позволяющий сопоставлять шаблонам пути к веб-странице определённые компоненты, подставлять идентификаторы в качестве параметров к компонентам и использовать вложенные маршруты. Объявление сопоставления маршрутов компонентам представлено в листинге \ref{listing:router}.

\begin{lstlisting}[caption={Объявление сопоставления маршрутов компонентам}, label={listing:router}]
{ path: '/', redirect: '/landing' },
{ path: '/',
    component: BaseLayout,
    children: [
        { path: 'sessions', component: SessionsPage},
        { path: 'analytics', component: AnalyticsPage },
    ],
    props: true},
{ path: '/landing', component: LandingPage },
{ path: '/error', component: ErrorPage},
{ path: '/oauth/:provider/oauth-callback', component: OAuthCallback },
{ path:'/change-password', component: ConfirmPasswordChange },
{ path: '/confirm-email', component: ConfirmEmail }
\end{lstlisting}

Для отрисовки текста статей, созданных в формате Markdown [12], использовалась библиотека marked. Она позволяет асинхронно отрисовывать текст в код HTML. Пример использования библиотеки marked представлен в листинге \ref{listing:marked}.

\begin{lstlisting}[caption={Использование библиотеки marked}, label={listing:marked}]
<template>
    <v-row>
        <div v-html="renderedMarkdown" class="markdown-renderer"></div>
    </v-row>
</template>
<script>
onMounted(async () => {
    const article_id = String(route.params.article_id)
    let response = await get_article(article_id)
    if (!response) {
        await router.push('/error')
    }
    Object.assign(article, response)
    renderedMarkdown.value = await marked(article.text);
    response = await fetch_data(`${Config.backend_address}/configs/`)
    if (response) {
        configs.value = response.data.list
    }
})
\end{lstlisting}

Библиотека Vuetify предоставляет набор компонентов, ускоряющих создание клиентской части веб-приложения. Пример использования компонентов библиотеки представлен в листинге \ref{listing:vuetify}.

\begin{lstlisting}[caption={Использование компонентов из библиотеки Vuetify}, label={listing:vuetify}]
<v-btn
    v-if="article.original_article_id === null"
><v-icon icon="mdi-earth"/></v-btn>
\end{lstlisting}

Данная библиотека предоставляет и другие компоненты: таблицы, меню, раскрывающиеся списки и прочие.

\SubsectionBetweenParagraphs{Выводы}

\begin{enumerate}
    \item Веб-приложение было реализовано с применением языка программирования Python и фреймворка FastAPI. Веб-приложение реализует все заявленные функциональные возможности пользователей.
    \item Для хранения данных использовалась СУБД PostgreSQL, для которой были созданы все необходимые объекты базы данных.
    \item Клиентская часть веб-приложения была реализована с применением фреймворка Vue и библиотеки компонентов Vuetify.
\end{enumerate}
